---
layout:     post
title: CS61B HW3 Hashing Answer Code and Notes
date:       2021-10-08 12:00:00
author:     "LPZhang"
catalog: false
header-style: text
tags: 
  - CS61B
  - Java
---


This homework helps us get better understanding of hash tables, which I have been struggled with a little bit. The requirements are at this [link](https://sp18.datastructur.es/materials/hw/hw3/hw3).

## Equals
First task is to overide `equals` method in `SimpleOomage`. Just make sure that all red, green and blue are equal, and consider *is self* and *null* situation.

```java
	@Override
    public boolean equals(Object o) {
        // TODO: Write this method.
        if (o == this) { return true; }
        if (o == null) { return false; }
        if (o.getClass() != this.getClass()) return false;
        SimpleOomage that = (SimpleOomage) o;
        return (this.red == that.red) && (this.green == that.green) && (this.blue == that.blue);
    }
```

## Hashcode
Also, we need to overide hashcode.
The Java specification for `equals` mentions this: 
> Note that it is generally necessary to override the `hashCode` method whenever the `equals` method is overridden, so as to maintain the general contract for the `hashCode` method, which states that equal objects must have equal hash codes.

Then finish the `testHashCodePerfect` of `TestSimpleOomage` with code that tests to see if the `hashCode` function is perfect. Make sure even if the sums of the three arguments from two `SimpleOomage` are equal, it still fails.

```java
    @Test
    public void testHashCodePerfect() {
        /* TODO: Write a test that ensures the hashCode is perfect,
          meaning no two SimpleOomages should EVER have the same
          hashCode UNLESS they have the same red, blue, and green values!
         */
        SimpleOomage ooA = new SimpleOomage(5, 10, 20);
        SimpleOomage ooA2 = new SimpleOomage(5, 10, 20);
        SimpleOomage ooB = new SimpleOomage(10, 5, 20);
        SimpleOomage ooC = new SimpleOomage(15, 5, 15);
        assertEquals(ooA.hashCode(), ooA2.hashCode());
        assertNotEquals(ooA.hashCode(), ooB.hashCode());
        assertNotEquals(ooA.hashCode(), ooC.hashCode());
    }
```

Overide `hashCode` function. Since all of the arguments (red, green and blue) are **multiples of 5** between 0 and 255, I divide them with 5 and represent them with power of 52(The interval is (0, 51)).

```java
    @Override
    public int hashCode() {
        if (!USE_PERFECT_HASH) {
            return red + green + blue;
        } else {
            // TODO: Write a perfect hash function for Simple Oomages.
            return (int)(red / 5 + green / 5 * 52 + blue / 5 * Math.pow(52, 2));
        }
    }
```

## Evaluating the perfect hashCode
Write a utility function that returns true if the given oomages have hashCodes that would distribute them fairly evenly across M buckets. To do this, convert each oomage's hashcode in the same way as in the visualizer, i.e. `(& 0x7FFFFFFF) % M` and ensure that no bucket has fewer than N / 50 Oomages and no bucket has more than N / 2.5 Oomages.
The number of buckets are decided by M, so it's fixed. Using a `int[]` to save the number of Oomages in each bucket will be appropriate.

```java
import java.util.List;

public class OomageTestUtility {
    public static boolean haveNiceHashCodeSpread(List<Oomage> oomages, int M) {
        int[] bucketList = new int[M];
        for (Oomage o : oomages) {
            int bucketNum = (o.hashCode() & 0x7FFFFFFF) % M;
            bucketList[bucketNum] = bucketList[bucketNum] + 1;
        }
        for (int k : bucketList) {
            System.out.println(k);
        }
        for (int j : bucketList) {
            if ((j < oomages.size() / 50) || (j > oomages.size() / 2.5)) {
                return false;
            }
        }
        return true;
    }
}
```

## Evaluating the perfect hashCode Visually

To get a better understanding of how hash tables work, we will use a hash table visualizer.
